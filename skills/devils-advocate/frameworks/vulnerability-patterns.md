# Common Vulnerability Patterns

Load this file when reviewing code implementations, database queries, APIs, or business logic for known failure patterns.

---

## 1. Database Vulnerabilities

```
❌ SQL Injection
   - Concatenated SQL strings with user input
   - Dynamic query building (string format/interpolation)
   - Stored procedures with dynamic SQL execution

❌ Performance Issues
   - Missing indexes on foreign keys and filter columns
   - N+1 query patterns (loading relations in a loop)
   - SELECT * instead of projecting specific columns
   - No query timeouts (long-running queries block the pool)

❌ Data Integrity
   - Missing foreign key constraints (orphaned records)
   - Operations not wrapped in transactions (partial writes)
   - Race conditions on concurrent updates (no row-level locking)
   - No optimistic locking (last-write-wins silently)
   - Soft deletes without cascading logic
```

---

## 2. API Vulnerabilities

```
❌ Authentication & Authorization
   - No JWT signature validation (accepts any token)
   - Missing authorization checks (IDOR — user A reads user B's data)
   - Role checks only at the route level, not at the service/data level
   - Sensitive tokens or keys returned in API responses or logged

❌ Input Validation
   - No request body size limits (payload amplification)
   - Missing type validation (accepts unexpected types/shapes)
   - No sanitization of stored content (stored XSS)
   - Accepting arbitrary JSON depth (stack overflow / CPU exhaustion)
   - File upload without type/size/content validation

❌ Rate Limiting & Availability
   - No rate limiting on public or unauthenticated endpoints
   - Per-IP limiting only (bypassable via proxies or distributed attack)
   - No exponential backoff enforced for retry-heavy clients
   - No circuit breaker protecting expensive downstream calls
   - Missing request timeout on outbound HTTP calls
```

---

## 3. Business Logic Vulnerabilities

```
❌ Race Conditions
   - Check-then-act without atomic enforcement (read balance → write deduction)
   - Double-spend: two concurrent requests both pass a balance check
   - Concurrent modification of shared state without locking
   - TOCTOU (Time-of-Check to Time-of-Use) gaps

❌ Calculation Errors
   - Using floating-point types for monetary amounts
   - Integer overflow on large quantities or aggregations
   - Rounding errors accumulating over many operations
   - Tax, discount, or fee logic applied in the wrong order

❌ State Machine Issues
   - Invalid state transitions permitted (COMPLETED → PENDING)
   - Missing terminal states (jobs that never reach DONE or FAILED)
   - No idempotency on retried operations (duplicate processing)
   - Incomplete rollback on multi-step workflows (partial success state)
   - No event ordering guarantee in async/event-driven flows
```

---

## 4. Infrastructure & Cloud Vulnerabilities

```
❌ IAM & Permissions
   - Overly permissive IAM roles (wildcard * actions or resources)
   - Hardcoded credentials in environment variables, configs, or source code
   - No secrets rotation policy
   - Service accounts with human-level permissions

❌ Network & Exposure
   - Publicly accessible storage buckets or databases
   - Missing VPC/firewall rules (default-allow instead of default-deny)
   - No encryption in transit between internal services
   - Open ports beyond what the service requires

❌ CI/CD Pipeline
   - Unverified third-party Actions or pipeline plugins (supply chain attack)
   - Secrets accessible to all branches/forks
   - No separation between build, test, and deploy environments
   - Production deployments without approval gate

❌ Observability Gaps
   - No structured logging (cannot correlate across services)
   - Missing distributed tracing (latency invisible across service calls)
   - No alerting on business-level anomalies (only infra metrics)
   - Log retention too short to support incident investigation
```
